/* 

Вопрос 1

Целочисленные:

1. int: Предназначен для хранения целых чисел. Размер обычно 4 байта (32 бита).

можно сказать что и чар

Числа с плавающей точкой:

1. float: Хранит числа с плавающей точкой одинарной точности (обычно 4 байта).

2. double: Используется для чисел с плавающей точкой двойной точности (обычно 8 байт).

Символьный тип:

1. char: Хранит один символ или числовое значение, представляющее код символа. Обычно 1 байт.

Другие типы данных:

1. void: Специальный тип, используемый для указания на отсутствие типа.

Квалификаторы типов:

1. signed: Указывает, что тип данных может хранить отрицательные и положительные значения.

2. unsigned: Тип данных, который может хранить только неотрицательные значения (от 0 до максимального значения).

3. short: Тип данных для коротких целых чисел. Обычно 2 байта (16 бит).

4. long: Используется для хранения больших целых чисел. Размер 4 или 8 байт (32 или 64 бита) в зависимости от компилятора и платформы.

5. long long: Предназначен для хранения очень больших целых чисел. Обычно 8 байт (64 бита).

Это основные типы данных в C. Кроме того, в языке есть возможность объявлять пользовательские типы данных с помощью `typedef`.

1. арифметические: +, -, /, *, %

2. логические: &&, ||, !
   - **Логическое И (`&&`), логическое ИЛИ (`||`), логическое НЕ (`!`)**: Применяются к булевым значениям (`0` - false, `1` - true). Возвращают булев результат (`0` или `1`).

3. бинарные: &, |, ^, <<(влево), >>(вправо)

Если сдвиг вправо производится на N позиций, то это числовое значение делится на 2^n
Если сдвиг влево производится на N позиций, то это числовое значение умножается на 2^n

4. операции сравнения: >, <, ==, !=, >=, <=

5. присваивание: =



Вопрос 2

Целые и вещественные числа хранятся в памяти компьютера с использованием различных форматов представления. Вот основные форматы представления чисел:

Целые числа:
    Представление отрицательных чисел: 
        Дополнительный код (Two's complement):
            Число -N представляется как инвертирование всех битов числа N и добавление единицы к полученному значению. 
            Это позволяет эффективно выполнять операции сложения и вычитания на уровне аппаратуры.
            Например, если у нас есть байт (8 бит), то диапазон чисел в дополнительном коде будет от -128 до 127.
    неотриц числа хранятся в обычном двоичном коде

Вещественные числа:

    IEEE 754 (для одинарной и двойной точности):

        Одинарная точность (float): Хранит числа с плавающей точкой одинарной точности (32 бита).
        Двойная точность (double): Хранит числа с плавающей точкой двойной точности (64 бита).

    Представление чисел в формате IEEE 754:

        Знак: 1 бит, который указывает на знак числа (0 для положительных чисел, 1 для отрицательных).
        Экспонента: Диапазон значений, который определяет порядок числа (смещенный на определенное значение).
        Мантисса: Значения фракций (мантиссы), которые представляют дробную часть числа.



Вопрос 5

Сложение/Вычитание целого числа с указателем: 
    Это изменяет адрес, на который указывает указатель, на количество байт, 
    соответствующее размеру указываемого типа данных. 
    Например, если p указывает на int, p++ увеличит адрес на sizeof(int) байт.

Вычитание одного указателя из другого:
    Результат вычитания указателей даст количество элементов (не байт), на которое они разделены друг от друга.



Вопрос 7

Файловый ввод/вывод в C обеспечивается с помощью библиотеки <stdio.h>, 
которая предоставляет функции для работы с файлами через структуру FILE.
FILE - это структура, содержащая информацию о файле, такую как указатель на его позицию, режим открытия, флаги ошибок и т.д.

Открытие и закрытие файлов:
    - fopen(): Функция открывает файл и возвращает указатель на его структуру FILE.
    - fclose(): Закрывает файл.

Методы чтения и записи файлов:
    - fprintf(): Записывает отформатированные данные в файл, аналогично printf().
    - fscanf(): Читает данные из файла, аналогично scanf().

Чтение файлов с обработкой символа конца файла:
    - feof(): Функция проверяет, достигнут ли конец файла. 
    - Цикл с feof(): Чтобы прочитать файл до конца, используется цикл с feof().
В другом случае чекаем на EOF

Типизированные и нетипизированные файлы:
    Основное различие между типизированными и нетипизированными файлами заключается в том,
    как данные обрабатываются и сохраняются в файле. 
    Типизированные файловые функции предполагают работу с определенными типами данных и предоставляют удобные методы работы с ними, 
    в то время как нетипизированные функции работают с данными на уровне байтов без учета их структуры или типа.    

- Типизированные файлы: Используются функции ввода-вывода, которые зависят от типа данных (fprintf(), fscanf()).
- Нетипизированные файлы: Используются функции, которые работают с байтами (fread(), fwrite()).

Форматируемый ввод/вывод:
    - Форматированный ввод/вывод осуществляется с помощью функций fprintf() и fscanf().

Методы выделения лексем из входного строкового потока:
    - fgets(): Считывает строку из файла.
    - fgetc(): Считывает символ из файла.
    - fscanf(): Может быть использован для разбора строки на лексемы с помощью спецификаторов формата.

Принцип границы и функция strtok():
    - strtok(): Функция разбивает строку на токены (лексемы) с помощью заданного сепаратора.
    - Принцип границы: strtok() использует статическую переменную, чтобы отслеживать позицию внутри строки между вызовами функции.



Вопрос 9

va_list: Этот тип представляет список аргументов.
va_start: Этот макрос инициализирует список аргументов.
va_arg: Этот макрос извлекает следующий аргумент из списка.
va_end: Этот макрос очищает список аргументов.



Вопрос 12

Директивы препроцессора в языке С - это инструкции, которые обрабатываются до фактической компиляции программы. 
Они начинаются с символа # и используются для создания условной компиляции,
включения файлов, создания макроопределений и других задач.

#include:
    Позволяет включать содержимое других файлов в программу.

#define:
    Создает макроопределение или макрос для замены текста в программе.

#ifdef / #ifndef / #endif:
    #ifdef проверяет, определено ли указанное имя.
    #ifndef проверяет, не определено ли указанное имя.
    #endif завершает блок условной компиляции.

#:
    Оператор строковизации. Превращает токен в строковый литерал.

##:
    Оператор слияния (конкатенации) токенов.

Если макроопределение принимает аргументы, особенно при использовании операций, учитывайте пробелы и скобки 
для избежания нежелательного поведения операторов.

При создании сложных макросов важно учитывать возможность ошибок и неправильного использования. 

Макросы заменяются до фактической компиляции кода.



Вопрос 17

Деревья общего вида представляют собой иерархическую структуру данных, где узлы могут иметь произвольное количество потомков. Каждый узел содержит значение и ссылки на своих детей.

Структура элемента дерева общего вида на языке C:
    typedef struct TreeNode 
    {
        int value; // Значение узла
        struct TreeNode* first_child; // Ссылка на первого потомка
        struct TreeNode* next_sibling; // Ссылка на следующего брата
    } TreeNode;
    
Операции над деревьями общего вида:
    Добавление узла: Создание нового узла и добавление его в качестве потомка к родительскому узлу.
    Удаление узла: Удаление узла из дерева и перераспределение связей между другими узлами.
    Поиск узла: Поиск узла по значению или по ключу.
    Обход дерева:
    Прямой обход (pre-order traversal): Посещение узла, затем его потомков слева направо.
    Обратный обход (post-order traversal): Посещение потомков узла слева направо, затем самого узла.
    Симметричный обход (in-order traversal): Посещение левого поддерева, затем узла и правого поддерева.
    Обход в ширину (breadth-first traversal): Посещение узлов по уровням, начиная с корня.
    Вычисление глубины узла: Определение расстояния от корня до узла.
    Вычисление высоты дерева: Определение максимальной глубины дерева.
    Подсчет количества узлов: Определение общего количества узлов в дереве.



Вопрос 26

Свойства хеш-функций:
    - Уникальность: Разные входные данные должны иметь разные хеши (однако, из-за ограниченности пространства хешей, коллизии невозможно избежать полностью).
    - Равномерное распределение: Хеш-функция должна равномерно распределять ключи по всему диапазону хешей.
    - Вычислительная эффективность: Функция должна работать быстро, даже для больших объемов данных.

*/