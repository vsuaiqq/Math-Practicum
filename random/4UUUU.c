/* 

Вопрос 1

Целочисленные:

1. int: Предназначен для хранения целых чисел. Размер обычно 4 байта (32 бита).

можно сказать что и чар

Числа с плавающей точкой:

1. float: Хранит числа с плавающей точкой одинарной точности (обычно 4 байта).

2. double: Используется для чисел с плавающей точкой двойной точности (обычно 8 байт).

Символьный тип:

1. char: Хранит один символ или числовое значение, представляющее код символа. Обычно 1 байт.

Другие типы данных:

1. void: Специальный тип, используемый для указания на отсутствие типа.

Квалификаторы типов:

1. signed: Указывает, что тип данных может хранить отрицательные и положительные значения.

2. unsigned: Тип данных, который может хранить только неотрицательные значения (от 0 до максимального значения).

3. short: Тип данных для коротких целых чисел. Обычно 2 байта (16 бит).

4. long: Используется для хранения больших целых чисел. Размер 4 или 8 байт (32 или 64 бита) в зависимости от компилятора и платформы.

5. long long: Предназначен для хранения очень больших целых чисел. Обычно 8 байт (64 бита).

Это основные типы данных в C. Кроме того, в языке есть возможность объявлять пользовательские типы данных с помощью `typedef`.

1. арифметические: +, -, /, *, %

2. логические: &&, ||, !
   - **Логическое И (`&&`), логическое ИЛИ (`||`), логическое НЕ (`!`)**: Применяются к булевым значениям (`0` - false, `1` - true). Возвращают булев результат (`0` или `1`).

3. бинарные: &, |, ^, <<(влево), >>(вправо)

Если сдвиг вправо производится на N позиций, то это числовое значение делится на 2^n
Если сдвиг влево производится на N позиций, то это числовое значение умножается на 2^n

4. операции сравнения: >, <, ==, !=, >=, <=

5. присваивание: =



Вопрос 2

Целые и вещественные числа хранятся в памяти компьютера с использованием различных форматов представления. Вот основные форматы представления чисел:

Целые числа:
    Представление отрицательных чисел: 
        Дополнительный код (Two's complement):
            Число -N представляется как инвертирование всех битов числа N и добавление единицы к полученному значению. 
            Это позволяет эффективно выполнять операции сложения и вычитания на уровне аппаратуры.
            Например, если у нас есть байт (8 бит), то диапазон чисел в дополнительном коде будет от -128 до 127.
    неотриц числа хранятся в обычном двоичном коде

Вещественные числа:

    IEEE 754 (для одинарной и двойной точности):

        Одинарная точность (float): Хранит числа с плавающей точкой одинарной точности (32 бита).
        Двойная точность (double): Хранит числа с плавающей точкой двойной точности (64 бита).

    Представление чисел в формате IEEE 754:

        Знак: 1 бит, который указывает на знак числа (0 для положительных чисел, 1 для отрицательных).
        Экспонента: Диапазон значений, который определяет порядок числа (смещенный на определенное значение).
        Мантисса: Значения фракций (мантиссы), которые представляют дробную часть числа.



Вопрос 5

Сложение/Вычитание целого числа с указателем: 
    Это изменяет адрес, на который указывает указатель, на количество байт, 
    соответствующее размеру указываемого типа данных. 
    Например, если p указывает на int, p++ увеличит адрес на sizeof(int) байт.

Вычитание одного указателя из другого:
    Результат вычитания указателей даст количество элементов (не байт), на которое они разделены друг от друга.



Вопрос 7

Файловый ввод/вывод в C обеспечивается с помощью библиотеки <stdio.h>, 
которая предоставляет функции для работы с файлами через структуру FILE.
FILE - это структура, содержащая информацию о файле, такую как указатель на его позицию, режим открытия, флаги ошибок и т.д.

Открытие и закрытие файлов:
    - fopen(): Функция открывает файл и возвращает указатель на его структуру FILE.
    - fclose(): Закрывает файл.

Методы чтения и записи файлов:
    - fprintf(): Записывает отформатированные данные в файл, аналогично printf().
    - fscanf(): Читает данные из файла, аналогично scanf().

Чтение файлов с обработкой символа конца файла:
    - feof(): Функция проверяет, достигнут ли конец файла. 
    - Цикл с feof(): Чтобы прочитать файл до конца, используется цикл с feof().
В другом случае чекаем на EOF

Типизированные и нетипизированные файлы:
    Основное различие между типизированными и нетипизированными файлами заключается в том,
    как данные обрабатываются и сохраняются в файле. 
    Типизированные файловые функции предполагают работу с определенными типами данных и предоставляют удобные методы работы с ними, 
    в то время как нетипизированные функции работают с данными на уровне байтов без учета их структуры или типа.    

- Типизированные файлы: Используются функции ввода-вывода, которые зависят от типа данных (fprintf(), fscanf()).
- Нетипизированные файлы: Используются функции, которые работают с байтами (fread(), fwrite()).

Форматируемый ввод/вывод:
    - Форматированный ввод/вывод осуществляется с помощью функций fprintf() и fscanf().

Методы выделения лексем из входного строкового потока:
    - fgets(): Считывает строку из файла.
    - fgetc(): Считывает символ из файла.
    - fscanf(): Может быть использован для разбора строки на лексемы с помощью спецификаторов формата.

Принцип границы и функция strtok():
    - strtok(): Функция разбивает строку на токены (лексемы) с помощью заданного сепаратора.
    - Принцип границы: strtok() использует статическую переменную, чтобы отслеживать позицию внутри строки между вызовами функции.



Вопрос 9

va_list: Этот тип представляет список аргументов.
va_start: Этот макрос инициализирует список аргументов.
va_arg: Этот макрос извлекает следующий аргумент из списка.
va_end: Этот макрос очищает список аргументов.



Вопрос 12

Директивы препроцессора в языке С - это инструкции, которые обрабатываются до фактической компиляции программы. 
Они начинаются с символа # и используются для создания условной компиляции,
включения файлов, создания макроопределений и других задач.

#include:
    Позволяет включать содержимое других файлов в программу.

#define:
    Создает макроопределение или макрос для замены текста в программе.

#ifdef / #ifndef / #endif:
    #ifdef проверяет, определено ли указанное имя.
    #ifndef проверяет, не определено ли указанное имя.
    #endif завершает блок условной компиляции.

#:
    Оператор строковизации. Превращает токен в строковый литерал.

##:
    Оператор слияния (конкатенации) токенов.

Если макроопределение принимает аргументы, особенно при использовании операций, учитывайте пробелы и скобки 
для избежания нежелательного поведения операторов.

При создании сложных макросов важно учитывать возможность ошибок и неправильного использования. 

Макросы заменяются до фактической компиляции кода.



Вопрос 17

Деревья общего вида представляют собой иерархическую структуру данных, где узлы могут иметь произвольное количество потомков. Каждый узел содержит значение и ссылки на своих детей.

Структура элемента дерева общего вида на языке C:
    typedef struct TreeNode 
    {
        int value; // Значение узла
        struct TreeNode* first_child; // Ссылка на первого потомка
        struct TreeNode* next_sibling; // Ссылка на следующего брата
    } TreeNode;
    
Операции над деревьями общего вида:
    Добавление узла: Создание нового узла и добавление его в качестве потомка к родительскому узлу.
    Удаление узла: Удаление узла из дерева и перераспределение связей между другими узлами.
    Поиск узла: Поиск узла по значению или по ключу.
    Обход дерева:
        Прямой обход (pre-order traversal): Посещение узла, затем его потомков слева направо.
        Обратный обход (post-order traversal): Посещение потомков узла слева направо, затем самого узла.
        Симметричный обход (in-order traversal): Посещение левого поддерева, затем узла и правого поддерева.
        Обход в ширину (breadth-first traversal): Посещение узлов по уровням, начиная с корня.
    Вычисление глубины узла: Определение расстояния от корня до узла.
    Вычисление высоты дерева: Определение максимальной глубины дерева.
    Подсчет количества узлов: Определение общего количества узлов в дереве.



Вопрос 22

Левосторонняя приоритетная очередь — это представление приоритетной очереди с помощью так называемого левостороннего бинарного дерева.
Узел называется неполным, если он имеет менее двух непосредственных потомков. В частности, листья дерева являются неполными узлами.
Рангом узла будем называть увеличенное на 1 расстояние (число ребер) от него до ближайшего неполного потомка.
Левостороннее дерево — это бинарное дерево, для каждого узла которого ранг его левого непосредственного потомка в расширенном дереве не меньше ранга его правого потомка.

Ниже описано для мин кучи в корне мин

typedef struct LeftistHeap 
{
    int key;
    int rank;
    struct LeftistHeap* left;
    struct LeftistHeap* right;
} LeftishHeap;

Все операции логарифмические кроме доступа к минимуму

Вставка элемента:
    При вставке нового элемента создается узел с указанным значением ключа.
    Этот узел затем сливается (merge) с текущей левосторонней приоритетной очередью.
    В процессе слияния учитываются ранги узлов для сохранения свойства левостороннего дерева (меньший приоритет - ближе к корню).

Поиск минимума:
    Доступ к минимальному элементу осуществляется путем обращения к корню дерева.

Удаление минимума:
    Удаление минимального элемента начинается с удаления корня (узла с минимальным приоритетом).
    Затем происходит слияние (merge) левого и правого поддеревьев для создания новой левосторонней приоритетной очереди.

Слияние двух левосторонних приоритетных очередей:
    Если одна из очередей пуста, возвращается другая.
    Выбирается узел с меньшим приоритетом в качестве корня новой очереди для поддержания свойства левостороннего дерева.
    Узел с меньшим рангом из корня и его правого поддерева выбирается в качестве правого поддерева для следующего рекурсивного вызова слияния.
    После рекурсивного слияния поддеревьев происходит обмен указателями между левым и правым поддеревьями корня  для сохранения свойства левостороннего дерева.
    После слияния поддеревьев рассчитывается новый ранг у корневого узла (минимальный ранг из его левого и правого поддеревьев, увеличенный на 1).
    Возвращается корень новой левосторонней приоритетной очереди.

Вот как можно описать процесс слияния без разрушения:
    Начинается с создания новой пустой левосторонней приоритетной очереди.
    Меньший корень становится корнем новой очереди.
    Затем рекурсивно объединяются поддеревья корня меньшей очереди и другой очереди.
    В результате операции слияния без разрушения получается новая очередь, при этом исходные очереди остаются нетронутыми.
    Код, реализующий слияние без разрушения исходных очередей, будет похож на код слияния с разрушением, за исключением того, что он вернет новую очередь, не меняя исходные.



Вопрос 23

Косая куча представляет собой кучу, реализованную как двоичное дерево. 
Преимущество косых куч заключается в их способности объединяться быстрее, чем в двоичных кучах. 
В отличие от двоичных куч здесь нет структурных ограничений, поэтому нет гарантии, что высота дерева является логарифмической. 
Должны быть соблюдены только два условия:
    - Общий порядок кучи должен быть соблюден.
    - Основная операция — слияние. Мы можем реализовать другие операции, используя только её.

структура дефолт для бин дерева

Ниже описано для мин кучи в корне мин
Все операции логарифмические кроме доступа к минимуму

Вставка элемента:
    Новый узел объединяется с текущей косой приоритетной очередью.
    Операция вставки выполняется через рекурсивное объединение узлов.

Поиск минимума/максимума:
    Доступ к минимальному (или максимальному) элементу осуществляется путем обращения к корню дерева.

Удаление минимума/максимума:
    Удаление минимального (или максимального) элемента начинается с удаления корневого узла.
    Затем левое и правое поддеревья объединяются для создания новой косой приоритетной очереди.

Слияние с разрушением:
    Выбор корня:
        Узел с наименьшим приоритетом становится новым корнем объединенной очереди.
    Рекурсивное объединение:
        Объединение осуществляется путем вызова слияния с разрушением для правого поддерева корня и левого поддерева из другой очереди.
    Освобождение памяти:
        При каждом объединении освобождается память для узлов, которые уже были включены в новую косую приоритетную очередь.

Слияние без разрушения:
    Выбор корня:
        Узел с наименьшим приоритетом становится новым корнем объединенной очереди.
    Рекурсивное объединение:
        Объединение осуществляется путем вызова слияния без разрушения для правого поддерева корня и левого поддерева из другой очереди.
    Сохранение исходных очередей:
        В отличие от слияния с разрушением, где память узлов освобождается, 
        слияние без разрушения сохраняет исходные очереди, поскольку узлы просто объединяются в новую очередь без изменения исходных.

Вопрос 24

Биномиальное дерево - это определенный вид дерева, которое строится рекурсивно путем объединения деревьев более низких рангов. 
Биномиальное дерево ранга k состоит из двух биномиальных деревьев ранга k-1, объединенных так, 
что одно из них является левым поддеревом корня другого.

Ранг биномиального дерева определяется рекурсивно и связан с числом узлов в этом дереве.
Биноминальное дерево ранга k содержит 2 ^ k узлов. Ранг также определяет количество поддеревьев определенного размера в дереве.
Биноминальное дерево ранга k имеет k + 1 поддеревьев, причём i-ое поддерево имеет размер 2 ^ (k - 1).

// Структура узла биномиального дерева
struct BinomialNode {
    int key;
    int degree; // Ранг дерева
    struct BinomialNode *child;
    struct BinomialNode *sibling;
    struct BinomialNode *parent;
};

// Структура для биномиальной приоритетной очереди на базе кольцевого списка
struct BinomialQueue {
    struct BinomialNode *head; // Список корней биномиальных деревьев
    int size; // Количество элементов в очереди
};

// Структура узла фибоначчиевого дерева
struct FibonacciNode {
    int key;
    struct FibonacciNode *parent;
    struct FibonacciNode *child;
    struct FibonacciNode *left;
    struct FibonacciNode *right;
    int degree; // Степень узла
    int mark; // Пометка для удаления минимального элемента
};

// Структура для фибоначчиевой приоритетной очереди на базе дерева общего вида
struct FibonacciQueue {
    int size; // Количество элементов в очереди
    struct FibonacciNode *min; // Минимальный элемент
    struct FibonacciNode *rootList; // Список корней деревьев
};

Давайте начнем с описания операций для биномиальной и фибоначчиевой приоритетных очередей на основе структур данных кольцевого списка и дерева общего вида.

Операции для биномиальной приоритетной очереди на основе кольцевого списка:
    1. Вставка элемента O(log n)
        - Слияние нового биномиального дерева из элемента с существующей кучей.
        - Объединение корней деревьев одинакового ранга.
    
    2. Поиск минимума/максимума O(1)
        - Поиск минимального (или максимального) элемента в корне каждого дерева.
        - Сравнение найденных значений для определения минимального (или максимального).
    
    3. Удаление минимума/максимума O(log n)
        - Разделение поддеревьев минимального (или максимального) элемента.
        - Объединение оставшихся поддеревьев для создания новой кучи.

    4. Слияние с разрушением и без разрушения O(log n)
        Слияние с разрушением:
            Берутся две биномиальные кучи.
            Объединяются их корни, сохраняя порядок убывания по рангу.
            Производится объединение корней деревьев одинакового ранга, и новый корень добавляется в список корней.
            После объединения кучи, исходные кучи теряют свою структуру.
        Слияние без разрушения:
            Берутся две биномиальные кучи.
            Объединяются их корни, сохраняя порядок убывания по рангу.
            Производится объединение корней деревьев одинакового ранга, и новый корень добавляется в список корней.
            После объединения кучи, исходные кучи остаются неизменными, и их поддеревья просто объединяются в новую кучу.


Операции для фибоначчиевой приоритетной очереди на основе дерева общего вида:
    1. Вставка элемента O(1)
        - Создание нового узла и добавление его в общий список корней фибоначчиевой кучи.

    2. Поиск минимума/максимума O(1)
        - Минимальный (или максимальный) элемент обычно хранится отдельно от основных деревьев. Это позволяет быстро найти минимальное (или максимальное) значение.

    3. Удаление минимума/максимума O(log n)
        - Извлечение минимального (или максимального) элемента и слияние его поддеревьев для создания новой кучи.

    4. Слияние с разрушением и без разрушения O(1)
        Слияние с разрушением:
            Берутся две фибоначчиевые кучи.
            Объединяются их списки корней, сохраняя порядок в соответствии с приоритетом.
            Поддеревья корней, у которых равные значения приоритета, объединяются.
            После объединения куч, исходные кучи теряют свою структуру.
        Слияние без разрушения:
            Берутся две фибоначчиевые кучи.
            Объединяются их списки корней, сохраняя порядок в соответствии с приоритетом.
            Поддеревья корней, у которых равные значения приоритета, объединяются.
            После объединения куч, исходные кучи остаются неизменными, и их поддеревья просто объединяются в новую кучу.
   


Вопрос 26

Свойства хеш-функций:
    - Уникальность: Разные входные данные должны иметь разные хеши (однако, из-за ограниченности пространства хешей, коллизии невозможно избежать полностью).
    - Равномерное распределение: Хеш-функция должна равномерно распределять ключи по всему диапазону хешей.
    - Вычислительная эффективность: Функция должна работать быстро, даже для больших объемов данных.



оффтоп:
    Приоритетная очередь — это абстрактная структура данных наподобие стека или очереди, 
    где у каждого элемента есть приоритет. 
    Элемент с более высоким приоритетом находится перед элементом с более низким приоритетом. 
    Если у элементов одинаковые приоритеты, они располагаются в зависимости от своей позиции в очереди. 
    Обычно приоритетные очереди реализуются с помощью куч.

    preorder_traverse(прямой): root, left, right
    postorder_traverse(обратный): left, right, root
    inorder_traverse(симметричный): left, root, right

*/